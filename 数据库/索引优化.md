## mysql瓶颈

1. CPU : cpu在饱和一般发生在数据装入内存或从磁盘读取数据的时候
2. IO：自盘IO瓶颈发生在装入数据远大于内存容量的时候
3. 服务器硬件：用top,free,iostat,vmstat来查看系统的性能状态

## explain（star）

使用EXPLAIN关键字可以**模拟优化器执行SQL语句**，从而知道MySQL是如何处理你的SQL语句的，**分析你的查询语句或是结构的性能瓶颈**

### 使用方法（生成执行计划）

`explain [sql语句]`

生成执行计划包含的信息，可以得到：

- 表的读取顺序（id）
- 数据读取操作的操作类型（select_type）
- 哪些索引可以被使用
- 哪些索引被实际使用
- 表之间的引用
- 每张表有多少行被优化器查询

### 执行计划包含的信息

 expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra

**概要描述：**

- **id**:选择标识符
- **select_type**:表示查询的类型。
- **table**:输出结果集的表
- **partitions**:匹配的分区、
- **type**:表示表的连接类型
- **possible_keys**:表示查询时，可能使用的索引
- **key**:表示实际使用的索引
- **key_len**:索引字段的长度
- **ref**:列与索引的比较
- **rows**:扫描出的行数(估算的行数)
- **filtered**:按表条件过滤的行百分比
- **Extra**:执行情况的描述和说明

### id -> 表的读取顺序

***id相同***：执行顺序由上而下

***id不同***：当**子查询**时，id的序号会递增，id越大则优先级越高、越先被执行

***id有相同有不同***： 相同id可以被认为是一组，组间优先级越大越先执行，组内从上到下顺序执行

### select_type->数据读取操作的操作类型

#### SIMPLE

简单`SELECT`，不包含`UNION`或子查询等

#### PRIMARY

子查询中最外层查询，查询中若包含任何复杂的子部分，**最外层的select被标记为`PRIMARY`**

#### SUBQUERY

子查询中的**第一个`SELECT`**，结果不依赖于外部查询

mysql> explain select * from t3 where id = (select id from t3 whereid=3952602 )  ;
+----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------------+
| id | select_type | table | type  | possible_keys    | key     | key_len | ref   |rows | Extra       |
+----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------------+
|  1 | PRIMARY     | t3    | const |PRIMARY,idx_t3_id | PRIMARY | 4   | const |   1 |             |
|  2 | SUBQUERY | t3    | const |PRIMARY,idx_t3_id | PRIMARY | 4   |            |    1 | Using index |
+----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------------+

#### DERIVED

在`FROM`列表中包含的子查询被标记为`DERIVED`,称为派生表，它被放在临时表中（会增加系统负担）

派生表的`SELECT`,` FROM`子句的子查询

mysql> explain select * from (select * from t3 where id=3952602) a ;
+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+
| id | select_type | table                | type     |possible_keys           | key         |key_len |ref      |rows| Extra |
+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+
|  1 | PRIMARY     | <derived2> | system |NULL                         | NULL      | NULL   | NULL|    1   |      |
|  2 | DERIVED     | t3                     | const    | PRIMARY,idx_t3_id | PRIMARY| 4          |           |    1   |      |
+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+

#### UNION

`UNION`中的**第二个或后面**的`SELECT`语句

- 若第二个`SELECT`出现在`UNION`之后，则会被标记为`UNION`；
- 若`UNION`包含在`FROM`子句的子查询中，外层`SELECT`将被标记为`DERIVED`

即标记DERIVED比标记UNION更优先

#### DEPENDENT UNION

`UNION`中的第二个或后面的`SELECT`语句，取决于外面的查询

#### UNION RESULT

UNION的结果，union语句中第二个select开始后面所有select都会生成

即从UNION表获得结果的SELECT

mysql> explain select * from t3 where id=3952602 union all select * from t3;
+----+--------------+------------+-------+-------------------+---------+---------+-------+------+-------+
| id | select_type  | table      |type  | possible_keys     | key    | key_len | ref   | rows | Extra |
+----+--------------+------------+-------+-------------------+---------+---------+-------+------+-------+
|  1 | PRIMARY      | t3        | const | PRIMARY,idx_t3_id | PRIMARY | 4      | const |    1 |       |
|  2 | UNION          | t3        | ALL   | NULL             | NULL    | NULL   | NULL  | 1000 |       |
|NULL | UNION RESULT | <union1,2> | ALL   | NULL             | NULL    |NULL    | NULL  | NULL |       |

注：第三个是临时表 相当于在外面套了一个`SELETE * FROM ();`?

#### DEPENDENT SUBQUERY

子查询中的第一个SELECT，依赖于外部查询

#### UNCACHEABLE SUBQUERY

一个子查询的结果不能被缓存，必须重新评估外链接的第一行 

### table

显式这一行的数据是关于哪张表

