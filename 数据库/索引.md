### 是什么

索引（index）是帮助MySQL高效获取数据的***数据结构***。

数据本身之外,数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法,这种数据结构就是索引。

索引可以包含**一个或多个列**的值，如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的**最左前缀列**。

目的是**提高查询效率**，可以类比字典。

一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往**以文件形式存储在硬盘**上

我们平时所说的索引，如果没有特别指明，都是指**B+树**(多路搜索树，并不一定是二叉树)结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引**默认都是使用B+树索引，统称索引**。

当然,除了B+树这种类型的索引之外，还有哈希索引(hash index)等。



### 优势

1. 类似大学图书馆建书目索引，减少了需要扫描的数据量，提高数据检索效率，**降低数据库的IO成本**
2. 通过索引列对数据进行排序，降低数据排序成本，**降低了CPU的消耗**
3. 将随机IO变为顺序IO

### 劣势

1. 实际上**索引也是一张表**，该表保存了主键和索引字段，并指向实体表的记录,所以**索引列也是要占用空间**的
2. 虽然索引大大提高了查询速度，同时却**会降低更新表的速度**,如果对表`INSERT`,`UPDATE`和`DELETE`。因为更新表时，MySQL不仅要不存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整**因为更新所带来的键值变化后的索引信息**
3. 索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立优秀的索引，或优化查询语句



### 分类

#### 单值索引 

即一个索引仅仅包含单个列，一个表可以有多个单列索引.

`ALTER TABLE table_name ADD INDEX index_name (column);`

#### 唯一索引

索引列的值必须唯一，可以为NULL。

`ALTER TABLE table_name ADD UNIQUE (column);`

**主键是一种唯一索引**

#### 复合索引

即一个索引包含多个列，多用于避免回表查询。

`ALTER mytable ADD INDEX <indexName> （columnName1, columnName2,...）;`

**使用复合索引时，范围搜索之后的搜索会失效**（<,<=,=,>,>=,between,like），and前后是可以乱序的，优化器会尽可能保证匹配的索引更多。

如创建复合(a,b,c,d)

若搜索条件是`b = 1 AND d = 2 AND a = 3 AND e = 4 AND c < 5`时，优化器首先会将顺序根据索引范围优化为`a = 3 AND b = 1 AND c < 5 AND d = 2 AND e = 4`，然后仅仅使用(a,b,c)进行索引。

 

### 基本语法

#### 创建

```mysql
CREATE [UNIQUE] INDEX <indexName> ON <mytable(columnName(length))>;
ALTER mytable ADD [UNIQUE] INDEX [<indexName>] (columnName);
```

#### 删除

```mysql
DROP INDEX [indexName] ON mytable;
```



#### 查看

```mysql
 SHOW INDEX FROM tableName\G
```



### 索引结构->BTree

使用BTree以为这所有的值都是按顺序存储，且**每个叶子页到根的距离相同**。

BTree可以加快访问数据的速度，因为存储引擎**不再需要进行全表扫描来获取需要的数据**，取而代之的是从根节点开始搜索，**通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点**，最终要么找到对应的值，要么该记录不存在。

通过BTree**可以大大减少IO读取次数**，比如一颗三层的BTree，找到目标仅仅需要3次IO，非常高效。

并且BTree对所有列是**顺序存储**的，且**叶子节点通过指针连接成一个链表**，所以**也非常适合查找范围数据**——仅仅需要找到首尾即可。



### 创建索引原则

1. 主键自动建立唯一索引
2. 频繁作为查询条件的字段应该创建索引
3. 查询中与其他表关联的字段，外键关系建立索引
4. 在高并发下倾向创建组合索引

5. 查询中排序（`ORDER BY`）的字段适合创建索引（**排序字段若通过索引去访问将大大提高排序速度**）
6. 查询中统计（`SUM`, `AVG`等）或者分组（`GROUP BY`）字段适合创建索引

7. 频繁更新的字段不适合创建索引

8. `WHERE`条件中用不到的字段不创建索引

9. 表记录过少不适合创建索引（百万级）

10. 经常增删改的表不适合创建索引

11. **数据包含过多重复内容且分布平均的字段不适合创建索引**
    索引的选择性指索引列中不同值的数目与表中记录数的比。

    **索引的选择性越接近1，索引的效率就越高**

12. 如果通配符 % 不出现在开头，则可以用到索引；类似'%a'无法触发索引

    

### 最左前缀原则

对于联合索引的多个索引段，会与查询语句中where从左自右一对一的进行匹配，当匹配不上或遇到范围查询（>、<、between、like）就停止匹配时则停止匹配。范围搜索会进行匹配。

它代表着首先必须**用到索引的第一个字段才会触发索引**。

mysql查询优化器会判断纠正语句该以什么样的顺序执行效率最高，故实际上**and前后是可以乱序**的，**优化器会尽可能保证匹配的索引更多**。



如创建复合(a,b,c,d)

若搜索条件是`b = 1 AND d = 2 AND a = 3 AND e = 4 AND c < 5`时，优化器首先会将顺序根据索引范围优化为`a = 3 AND b = 1 AND c < 5 AND d = 2 AND e = 4`，然后仅仅使用(a,b,c)进行索引。

### 覆盖索引

建立的索引的字段与select查询的字段的个数和顺序完全一致

即select的**数据列只用从索引中就能够取得**，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。

即便没有where（possible_key为NULL），也可以触发索引（显示在key，且select_type为index）